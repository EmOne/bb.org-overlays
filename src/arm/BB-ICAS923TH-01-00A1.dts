/*
* Copyright (C) 2018 Anol Paisal <info@emone.co.th>
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License version 2 as
* published by the Free Software Foundation.
*/

/dts-v1/;
/plugin/;

#include <dt-bindings/board/am335x-bbw-bbb-base.h>
#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/pinctrl/am33xx.h>
#include <dt-bindings/interrupt-controller/irq.h>

/ {
	compatible = "ti,beaglebone", "ti,beaglebone-black";

	/* identification */
	part-number = "BB-ICAS923TH-01";
	version = "00A1";

	/* state the resources this cape uses */
	exclusive-use =
		/* the pin header uses */
		"P8.37",	/* uart5_txd iC980A_GPS_RX*/
		"P8.38",	/* uart5_rxd iC980A_GPS_TX*/
		
		"P9.11",	/* uart4_rxd_mux2 CEL_TX*/
		"P9.13",	/* uart4_txd_mux2 CEL_RX*/
		
		"P9.24",	/* uart1_txd BBB_PI_TX*/
		"P9.26",	/* uart1_rxd BBB_PI_RX*/
		
		"P9.21",	/* spi0_d0 HOST_MISO*/
		"P9.18",	/* spi0_d1 HOST_MOSI*/
		"P9.22",	/* spi0_sclk HOST_SCK*/
		"P9.17",	/* spi0_cs0 HOST_CS$3*/
		
		"P9.29",	/* spi1_d0 SPI1_MISO*/
		"P9.30",	/* spi1_d1 SPI1_MOSI*/
		"P9.31",	/* spi1_sclk SPI1_SCK*/
        "P9.28",	/* spi1_cs0 SPI1_NSS$10*/
		"P9.42",	/* spi1_cs1 SPI1_NSS$5*/

		"P9.19",	/* i2c2_scl HOST_SCL*/
		"P9.20",	/* i2c2_sda HOST_SDA*/
		
		"P9.23",	/* gpio1_17 iC980A_RST$2*/
		"P9.25",	/* gpio3_21 CEL_W_DIS$9*/
		"P9.27",	/* gpio3_19 CEL_NRST$6*/
		"P9.41",	/* gpio0_20 CEL_WAKE$4*/
		"P9.12",	/* gpio1_28 GPS_RST$1*/
		"P9.14",	/* gpio1_18 LR_NOTE$7*/
		"P9.15",	/* gpio1_16 EN_GPS$8*/
		
		/* the hardware ip uses */
		"uart5",
		"uart4",
		"uart1",
		
		"spi0",
		"gpio0_5",	
		
		"spi1",
		"gpio0_7",
		"gpio3_17",
		
		"i2c2",
		
		"gpio1_17",	
		"gpio3_21",
		"gpio3_19",
		"gpio0_20",
		"gpio1_18",
		"gpio1_28",
		"gpio1_16";
	
	/*
	 * Helper to show loaded overlays under: /proc/device-tree/chosen/overlays/
	 */
	fragment@0 {
		target-path="/";
		__overlay__ {

			chosen {
				overlays {
					BB-ICAS923TH-01 = __TIMESTAMP__;
				};
			};
		};
	};	
	
	/*
	 * Free up the pins used by the mikrobus port from the pinmux helpers.
	 * pins are listed in clockwise order of their appearance in the
	 * mikrobus port.
	 */
	fragment@1 {
		target = <&ocp>;
		__overlay__ {			

			P8_37_pinmux { status = "disabled"; };
			P8_38_pinmux { status = "disabled"; };
			P9_13_pinmux { status = "disabled"; };
			P9_11_pinmux { status = "disabled"; };
			P9_24_pinmux { status = "disabled"; };
			P9_26_pinmux { status = "disabled"; };
			P9_21_pinmux { status = "disabled"; };
			P9_22_pinmux { status = "disabled"; };
			P9_17_pinmux { status = "disabled"; };
			P9_18_pinmux { status = "disabled"; };
			P9_28_pinmux { status = "disabled"; };
			P9_29_pinmux { status = "disabled"; };
			P9_30_pinmux { status = "disabled"; };
			P9_31_pinmux { status = "disabled"; };
			P9_42_pinmux { status = "disabled"; };
			P9_19_pinmux { status = "disabled"; };
			P9_20_pinmux { status = "disabled"; };
			P9_23_pinmux { status = "disabled"; };
			P9_25_pinmux { status = "disabled"; };
			P9_27_pinmux { status = "disabled"; };
			P9_41_pinmux { status = "disabled"; };
			P9_12_pinmux { status = "disabled"; };
			P9_14_pinmux { status = "disabled"; };
			P9_15_pinmux { status = "disabled"; };
		};
	};
	
	fragment@2 {
		target = <&am33xx_pinmux>;

		__overlay__ {
		
			/* avoid stupid warning */
        	#address-cells = <1>;
	        #size-cells = <1>;

			bb_spi0_pins: pinmux_bb_spi0_pins {
				pinctrl-single,pins = <
					BONE_P9_22 0x30 /* AM33XX_PADCONF(AM335X_PIN_SPI0_SCLK, PIN_OUTPUT, MUX_MODE0)	P9.22 spi0_sclk, INPUT_PULLUP | MODE0 */
					BONE_P9_21 0x30 /* AM33XX_PADCONF(AM335X_PIN_SPI0_D0, PIN_INPUT, MUX_MODE0)	P9.21 spi0_d0, INPUT_PULLUP | MODE0 */
					BONE_P9_18 0x10 /* AM33XX_PADCONF(AM335X_PIN_SPI0_D1, PIN_OUTPUT, MUX_MODE0)	P9.18 spi0_d1, OUTPUT_PULLUP | MODE0 */
					BONE_P9_17 0x10 /* AM33XX_PADCONF(AM335X_PIN_SPI0_CS0, PIN_OUTPUT, MUX_MODE0) P9.17 spi0_cs0, OUTPUT_PULLUP | MODE0 */
				>;
			};
			
			bb_spi1_pins: pinmux_bb_spi1_pins {
				pinctrl-single,pins = <
					BONE_P9_31 0x33	/* P9.31 mcasp0_aclkx.spi1_sclk, INPUT_PULLUP | MODE3 */
					BONE_P9_29 0x33	/* P9.29 mcasp0_fsx.spi1_d0, INPUT_PULLUP | MODE3 */
					BONE_P9_30 0x13	/* P9.30 mcasp0_axr0.spi1_d1, OUTPUT_PULLUP | MODE3 */
					BONE_P9_28 0x13  /* P9.28 mcasp0_ahclkr.spi1_cs0, OUTPUT_PULLUP | MODE3 */
					BONE_P9_42 0x12	/* P9.42 eCAP0_in_PWM0_out.spi1_cs1 OUTPUT_PULLUP | MODE2 */
				>;
			};
			
			bb_i2c2_pins: pinmux_bb_i2c2_pins {
				pinctrl-single,pins = <
					BONE_P9_19 0x73	/* P9.19 uart1_rtsn.i2c2_scl, SLEWCTRL_SLOW | INPUT_PULLUP | MODE3 */
					BONE_P9_20 0x73	/* P9.20 uart1_ctsn.i2c2_sda, SLEWCTRL_SLOW | INPUT_PULLUP | MODE3 */
				>;
			};
			
			bb_uart1_pins: pinmux_bb_uart1_pins {
				pinctrl-single,pins = <
					BONE_P9_26 (PIN_INPUT_PULLUP | MUX_MODE0)	/* P9.26 uart1_rxd | MODE0 INPUT */
					BONE_P9_24 (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* P9.24 uart1_txd | MODE0 OUTPUT */
				>;
			};
			
			bb_uart4_pins: pinmux_bb_uart4_pins {
				pinctrl-single,pins = <
					BONE_P9_11 (PIN_INPUT_PULLUP | MUX_MODE6) /* P9.11 gpmc_wait0.uart4_rxd | MODE6 INPUT */
					BONE_P9_13 (PIN_OUTPUT_PULLDOWN | MUX_MODE6) /* P9.13 gpmc_wpn.uart4_txd | MODE6 OUTPUT */
				>;
			};
			
			bb_uart5_pins: pinmux_bb_uart5_pins {
				pinctrl-single,pins = <
					BONE_P8_38 (PIN_INPUT_PULLUP | MUX_MODE4) /* P8.38 lcd_data9.uart5_rxd | MODE4 INPUT */
					BONE_P8_37 (PIN_OUTPUT_PULLDOWN | MUX_MODE4) /* P8.37 lcd_data8.uart5_txd | MODE4 OUTPUT */
				>;
			};
			
			bb_gpio_pins: pinmux_bb_gpio_pins {
				pinctrl-single,pins = <
					BONE_P9_15 0x37	/* P9.15 gpmc_a0.gpio1_16, OUTPUT_PULLUP | MODE7 */
					BONE_P9_23 0x37	/* P9.23 gpmc_a1.gpio1_17, OUTPUT_PULLUP | MODE7 */
					BONE_P9_14 0x37  /* P9.14 gpmc_a2.gpio1_18, OUTPUT_PULLUP | MODE7 */
					BONE_P9_12 0x37	/* P9.12 gpmc_be1n.gpio1_28, OUTPUT_PULLUP | MODE7 */
					BONE_P9_27 0x37  /* P9.27 mcasp0_fsr.gpio3_19, OUTPUT_PULLUP | MODE7 */
					BONE_P9_25 0x37  /* P9.25 mcasp0_ahclkx.gpio3_21, OUTPUT_PULLUP | MODE7 */
					BONE_P9_41 0x37	/* P9.41 xdma_event_intr1.gpio0_20, OUTPUT_PULLUP | MODE7 */
				>;
			};
		};
	};

	fragment@3 {
		target = <&spi0>;	/* spi0 is numbered correctly */
		__overlay__ {
			status = "okay";
			pinctrl-names = "default";
			pinctrl-0 = <&bb_spi0_pins>;

			#address-cells = <1>;
			#size-cells = <0>;

			/*
			 * Select the D0 pin as output and D1 as
			 * input. The default is D0 as input and
			 * D1 as output.
			 */
			//ti,pindir-d0-out-d1-in;
			
			/* add any spi devices connected here */
			/* note that you can do direct SPI via spidev now */
            channel@0 {
				#address-cells = <1>;
				#size-cells = <0>;

				compatible = "spidev";
				symlink = "spi/0.0";

				reg = <0>;
				spi-max-frequency = <16000000>;
				spi-cpha;
			};

			channel@1 {
				status = "disabled";
			};
		};
	};
	
	fragment@4 {
		target = <&spi1>;	/* spi1 is numbered correctly */
		__overlay__ {
			status = "okay";
			pinctrl-names = "default";
			pinctrl-0 = <&bb_spi1_pins>;

			#address-cells = <1>;
			#size-cells = <0>;

			/*
			 * Select the D0 pin as output and D1 as
			 * input. The default is D0 as input and
			 * D1 as output.
			 */
			//ti,pindir-d0-out-d1-in;
			
			ti,pio-mode; /* disable dma when used as an overlay, dma gets stuck at 160 bits... */
			
			/* add any spi devices connected here */
			/* note that you can do direct SPI via spidev now */
            channel@0 {
                #address-cells = <1>;
                #size-cells = <0>;
				
                compatible = "spidev";
				symlink = "spi/1.0";
				
                reg = <0>;
                spi-max-frequency = <16000000>;
            };
			
			channel@1 {
				#address-cells = <1>;
				#size-cells = <0>;

				compatible = "spidev";
				symlink = "spi/1.1";

				reg = <1>;
				spi-max-frequency = <16000000>;
				spi-cpol;
                spi-cpha;
			};
		};
	};
	
	
	
	fragment@5 {
		target = <&i2c2>;	/* i2c2 is numbered correctly */
		__overlay__ {
			status = "okay";
			pinctrl-names = "default";
			pinctrl-0 = <&bb_i2c2_pins>;

			/* this is the configuration part */
			clock-frequency = <400000>;	

			#address-cells = <1>;
			#size-cells = <0>;

			/* add any i2c devices on the bus here */
			

		};
	};
	
	fragment@6 {
		target = <&uart2>;	/* really uart1 */
		__overlay__ {
			status = "okay";
			pinctrl-names = "default";
			pinctrl-0 = <&bb_uart1_pins>;
		};
	};
	
	fragment@7 {
		target = <&uart4>;	/* really uart4 */
		__overlay__ {
			status = "okay";
			pinctrl-names = "default";
			pinctrl-0 = <&bb_uart4_pins>;
		};
	};
	
	fragment@8 {
		target = <&uart5>;	/* really uart5 */
		__overlay__ {
			status = "okay";
			pinctrl-names = "default";
			pinctrl-0 = <&bb_uart5_pins>;
		};
	};
};
